class SeaSalt_Common{constructor(config){this.config={algorithm:"xchacha",secret:"changeme3xg4#",pwhash:"argon2",pwsecurity:"normal"};this.state={ready:false,aead:false};if(["argon2","scrypt"].indexOf(this.config.pwhash)===-1)this.config.pwhash="argon2";if(typeof config==="object")for(let i in config)if(config.hasOwnProperty(i))this.config[i]=config[i];if(typeof this.config.logger==="undefined")this.config.logger=console.log;this.pwhash={};this.pwhash.argon2=new SeaSalt_PWHash_Argon2;this.pwhash.scrypt=
    new SeaSalt_PWHash_SCrypt;this.tools=new SeaSalt_Tools(this.config);this.secretbox=new SeaSalt_AEAD_SecretBox(this.config);this.aead={};this.aead.xchacha=new SeaSalt_AEAD_XChaCha(this.config);this.hash=new SeaSalt_Hashing;if(sodium){this.config.logger("SeaSalt - Loaded successfully");this.state.ready=true;this.state.aead=this.aead_test()}else console.error("SeaSalt - Libsodium was not found")}encrypt(string,secret,box){if(!string)throw"SeaSalt.encrypt() requires a string or object to encrypt";if(!secret)secret=
    this.config.secret;if(!secret)throw"SeaSalt.encrypt() could not find a password to use";if(typeof this.aead[this.config.algorithm]==="object")return this.aead[this.config.algorithm].encrypt(string,secret,box);else throw"SeaSalt.encrypt() received invalid algorithm - "+this.config.algorithm;}decrypt(string,secret,box){if(!string)throw"SeaSalt.decrypt() requires a string to decrypt";if(!secret)secret=this.config.secret;if(!secret)throw"SeaSalt.decrypt() could not find a password to use";if(typeof this.aead[this.config.algorithm]===
    "object")return this.aead[this.config.algorithm].decrypt(string,secret,box);else throw"SeaSalt.decrypt() received invalid algorithm - "+this.config.algorithm;}pwhash_create(password,security,algorithm){if(!algorithm)algorithm=this.config.pwhash;if(algorithm&&Object.keys(this.pwhash).indexOf(algorithm)===-1)algorithm=this.config.pwhash;return this.pwhash[algorithm].create(password,security)}pwhash_verify(hash,password,algorithm){if(!algorithm)algorithm=this.config.pwhash;if(algorithm&&Object.keys(this.pwhash).indexOf(algorithm)===
    -1)algorithm=this.config.pwhash;return this.pwhash[algorithm].verify(hash,password)}test(){let result=sodium.to_hex(sodium.crypto_generichash(64,"test"));return result==="a71079d42853dea26e453004338670a53814b78137ffbed07603a41d76a483aa9bc33b582f77d30a65e6f29a896c0411f38312e1d66e0bf16386c86a89bea572"}aead_test(){let original="test";let ciphertext=this.encrypt(original);let result=this.decrypt(ciphertext);return original===result}}class SeaSalt extends SeaSalt_Common{}
class SeaSalt_Hashing{constructor(string,salt,hash,format){this.reservedProperties=["constructor","toString"];this.validHashes=["sha256","sha512","generic","short"];this.validFormats=["hex","binary","base64"];if(this.validHashes.indexOf(salt)>-1){hash=salt;salt=undefined}if(typeof string==="string"){let props=Object.getOwnPropertyNames(Object.getPrototypeOf(new SeaSalt_Hashing));for(let x=0;x<this.reservedProperties.length;x++)props.splice(props.indexOf(this.reservedProperties[x]),1);props=JSON.parse(JSON.stringify(props));
    if(typeof hash==="undefined")hash="sha256";if(this.validFormats.indexOf(format)===-1)format="hex";if(props.indexOf(hash)===-1)throw"Invalid hash algorithm requested.";if(["generic","short"].indexOf(hash)>-1){this.hex=this[hash](string,salt);this.binary=sodium.from_hex(this.hex);this.base64=sodium.to_base64(this.binary)}else{this.binary=this[hash](string,salt,"binary");this.hex=sodium.to_hex(this.binary);this.base64=sodium.to_base64(this.binary)}this.format=format;this.length=this[this.format].length}}toString(){return this.hex}sha256(string,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                salt,format){if(salt instanceof Uint8Array)salt=sodium.to_hex(salt);if(typeof salt!=="string")salt="";if(!format)format="hex";if(this.validFormats.indexOf(format)===-1)format="hex";let salted=string;if(salt.length>0)salted=salt+string.substr(0,Math.floor(string.length/2))+salt+string.substr(Math.floor(string.length/2),string.length)+salt;let result=sodium.crypto_hash_sha256(salted);if(format==="hex")return sodium.to_hex(result);if(format==="base64")return sodium.to_base64(result);return result}sha512(string,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          salt,format){if(salt instanceof Uint8Array)salt=sodium.to_hex(salt);if(typeof salt!=="string")salt="";if(!format)format="hex";if(this.validFormats.indexOf(format)===-1)format="hex";let salted=string;if(salt.length>0)salted=salt+string.substr(0,Math.floor(string.length/2))+salt+string.substr(Math.floor(string.length/2),string.length)+salt;let result=sodium.crypto_hash_sha512(salted);if(format==="hex")return sodium.to_hex(result);if(format==="base64")return sodium.to_base64(result);return result}generic(string,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     key,config){if(typeof key==="object"&&!(key instanceof Uint8Array)){config=key;key=undefined}if(typeof config!=="object")config={};if(typeof config.size!=="number")config.size=sodium.crypto_generichash_BYTES;if(config.size<sodium.crypto_generichash_BYTES&&config.force!==true)throw"Requested size is smaller than minimum ("+sodium.crypto_generichash_BYTES+") and force is not set to true";if(config.size>sodium.crypto_generichash_BYTES*2)throw"Requested size is larger than the maximum sized allowed ("+
sodium.crypto_generichash_BYTES*2+")";if(config.size<1)throw"Requested size is too small";if(typeof key==="string"||key instanceof Uint8Array)config.key=key;if(typeof config.key!=="string"&&!(config.key instanceof Uint8Array))config.key=undefined;return sodium.to_hex(sodium.crypto_generichash(config.size,string,config.key))}short(string,key){if(typeof key==="undefined")key="";if(key==="random")key=sodium.randombytes_buf(sodium.crypto_shorthash_KEYBYTES);if(typeof key==="string"&&key.match(/^([a-fA-F0-9]{32})$/)===
    null)key=sodium.from_hex(this.generic(key,{size:sodium.crypto_shorthash_KEYBYTES,force:true}));if(typeof key==="string")key=sodium.from_hex(key);return sodium.to_hex(sodium.crypto_shorthash(string,key))}long(string,key){if(typeof key==="undefined")key="";if(key==="random")key=sodium.randombytes_buf(sodium.crypto_shorthash_siphashx24_KEYBYTES);if(typeof key==="string"&&key.match(/^([a-fA-F0-9]{32})$/)===null)key=sodium.from_hex(this.generic(key,{size:sodium.crypto_shorthash_siphashx24_KEYBYTES,force:true}));
    if(typeof key==="string")key=sodium.from_hex(key);return sodium.to_hex(sodium.crypto_shorthash_siphashx24(string,key))}}
class SeaSalt_PWHash_Argon2{create(password,security){let opsLimit=sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE;if(!security)security="normal";if(["light","normal","moderate","high"].indexOf(security)===-1)security="normal";if(security==="normal")opsLimit=opsLimit*2;else if(security==="moderate")opsLimit=opsLimit*4;else if(security==="high")opsLimit=opsLimit*6;return sodium.crypto_pwhash_str(password,opsLimit,sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE)}verify(hash,password){return sodium.crypto_pwhash_str_verify(hash,
    password)}derive(secret,salt,config){if(typeof salt==="object"&&!(salt instanceof Uint8Array)){config=salt;salt=undefined}if(typeof config!=="object")config={};if(typeof config.salt==="string")salt=sodium.from_hex(config.salt);if(typeof salt==="string")salt=sodium.from_hex(salt);if(!(salt instanceof Uint8Array))salt=sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);if(typeof config.ops==="undefined")config.ops=sodium.crypto_pwhash_OPSLIMIT_SENSITIVE*2;if(typeof config.mem==="undefined")config.mem=
    sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE;if(typeof config.alg==="undefined")config.alg=sodium.crypto_pwhash_ALG_DEFAULT;if(typeof config.size==="undefined")config.size=32;return{salt:sodium.to_hex(salt),key:sodium.to_hex(sodium.crypto_pwhash(config.size,secret,salt,config.ops,config.mem,config.alg))}}}
class SeaSalt_PWHash_SCrypt{create(password,security){let opsLimit=sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE;let memLimit=sodium.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE;if(!security)security="normal";if(["light","normal","moderate","high"].indexOf(security)===-1)security="normal";if(security==="normal")opsLimit=sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE*3;else if(security==="moderate")opsLimit=(sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE+
    sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE)*.25;else if(security==="high")opsLimit=sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE;let result=sodium.crypto_pwhash_scryptsalsa208sha256_str(password,opsLimit,memLimit);return result}verify(hash,password){return sodium.crypto_pwhash_scryptsalsa208sha256_str_verify(hash,password)}derive(secret,salt,config){if(typeof salt==="object"&&!(salt instanceof Uint8Array)){config=salt;salt=undefined}if(typeof config!=="object")config=
    {};if(typeof config.salt==="string")salt=sodium.from_hex(config.salt);if(typeof salt==="string")salt=sodium.from_hex(salt);if(!(salt instanceof Uint8Array))salt=sodium.randombytes_buf(sodium.crypto_pwhash_scryptsalsa208sha256_SALTBYTES);if(typeof config.ops==="undefined")config.ops=sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE*10;if(typeof config.mem==="undefined")config.mem=sodium.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE;if(typeof config.alg==="undefined")config.alg=
    sodium.crypto_pwhash_scryptsalsa208sha256_ALG_DEFAULT;if(typeof config.size==="undefined")config.size=32;return{salt:sodium.to_hex(salt),key:sodium.to_hex(sodium.crypto_pwhash_scryptsalsa208sha256(config.size,secret,salt,config.ops,config.mem,config.alg))}}}
class SeaSalt_AEAD_SecretBox{constructor(userPassword,secretItem,config){this.config={logger:console.log,minimumEntropy:1,minimumKeyLength:1,minimumStrength:0,key:"aead",cipher:"xchacha",salt:undefined};if(typeof userPassword==="object"){config=userPassword;userPassword=undefined;secretItem=undefined}if(typeof secretItem==="object"){config=secretItem;secretItem=undefined;if(config.keysalt||config.secret){secretItem={keysalt:config.keysalt,secret:config.secret};delete config.keysalt;delete config.secret}}if(typeof config===
    "object")for(let i in config)if(config.hasOwnProperty(i))this.config[i]=config[i];this.hash=new SeaSalt_Hashing;this.tools=new SeaSalt_Tools(config);this.aead=new SeaSalt_AEAD(this.config);if(userPassword)this.box=this.create(userPassword,secretItem)}toString(){return this.box}create(userPassword,secretItem){if(this.box)return this.box;if(this.tools.passwordStrength(userPassword)<this.config.minimumStrength)throw"Supplied password does not meet the minimum strength requirements.";if(typeof secretItem===
    "function")throw"Funcation are not valid secret items";if(typeof secretItem==="object"&&typeof secretItem.secret!=="string")secretItem.secret=this.aead.key();if(typeof secretItem==="undefined")secretItem=this.aead.key();secretItem=JSON.stringify(secretItem);if(typeof secretItem!=="string")throw"Supplied secret item cannot be converted to a string.";let aead=new SeaSalt_AEAD(this.config);this.box=aead.encrypt(secretItem,userPassword);let contents=aead.decrypt(this.box,userPassword);if(contents!==secretItem){this.config.logger("SeaSalt/AEAD/box_create - Failed to validate box contents");
    throw"Failed to validate the box contents.";}return this.box}repackage(box,userPassword,newPassword){if(!box&&!this.box)throw"Secret box must be provided for repackaging.";if(box&&userPassword&&!newPassword){if(!this.box)throw"Secret box must be provided for repackaging.";newPassword=userPassword;userPassword=box;box=this.box}if(!box||!userPassword||!newPassword)throw"Required arguments are missing";if(this.tools.passwordStrength(newPassword)<this.config.minimumStrength)return;let contents;try{contents=
    JSON.parse((new SeaSalt_AEAD(this.config)).decrypt(box,userPassword))}catch(e){}if(["string","object"].indexOf(typeof contents)===-1)return box;this.box=this.create(newPassword,contents);return this.box}check(box,userPassword,secretItem){if(!box&&!this.box)throw"Secret box must be provided for checking.";if(box&&!userPassword){if(!this.box)throw"Secret box must be provided for repackaging.";userPassword=box;box=this.box}if(!box||!userPassword)throw"Required arguments are missing";let aead=new SeaSalt_AEAD(this.config);
    if(typeof secretItem==="undefined"){let result;try{result=aead.decrypt(box,userPassword)}catch(e){return false}return result===true}if(secretItem&&typeof secretItem==="boolean")secretItem=secretItem===false?"false":"true";if(secretItem&&typeof secretItem==="number")secretItem=secretItem.toString();if(secretItem&&typeof secretItem==="object")secretItem=JSON.stringify(secretItem,null,5);if(secretItem&&typeof secretItem!=="string")return false;let contents=aead.decrypt(box,userPassword);return secretItem&&
        contents===secretItem||typeof contents==="string"}}
class SeaSalt_AEAD{constructor(string,secret,box,config){if((typeof box==="object"||typeof secret==="object")&&typeof config==="undefined"){if(typeof secret==="object"){config=secret;secret=undefined;box=undefined}if(typeof box==="object"&&(!(box instanceof SeaSalt_AEAD_SecretBox)||!box.box)){config=box;box=undefined}}if(typeof string==="object"){config=string;string=undefined}this.ciphers={xchacha:{nonce_bytes:sodium.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES,encrypt:sodium.crypto_aead_xchacha20poly1305_ietf_encrypt,
        decrypt:sodium.crypto_aead_xchacha20poly1305_ietf_decrypt,keygen:sodium.crypto_aead_xchacha20poly1305_ietf_keygen},chacha20_ietf:{nonce_bytes:sodium.crypto_aead_chacha20poly1305_ietf_NPUBBYTES,encrypt:sodium.crypto_aead_chacha20poly1305_ietf_encrypt,decrypt:sodium.crypto_aead_chacha20poly1305_ietf_decrypt,keygen:sodium.crypto_aead_chacha20poly1305_ietf_keygen},chacha20:{nonce_bytes:sodium.crypto_aead_chacha20poly1305_NPUBBYTES,encrypt:sodium.crypto_aead_chacha20poly1305_encrypt,decrypt:sodium.crypto_aead_chacha20poly1305_decrypt,
        keygen:sodium.crypto_aead_chacha20poly1305_keygen}};this.config={key:"aead",logger:console.log,minimumEntropy:1,minimumKeyLength:1,minimumStrength:0,cipher:"xchacha",salt:undefined};if(typeof config==="object")for(let i in config)if(config.hasOwnProperty(i))this.config[i]=config[i];if(typeof this.config.cipher==="string"&&typeof this.ciphers[this.config.cipher]!=="object")throw"Requested cipher is not valid";this.sodium=this.ciphers[this.config.cipher];if(typeof this.config.secret==="string"){secret=
    this.config.secret;delete this.config.secret}this.hash=new SeaSalt_Hashing;this.tools=new SeaSalt_Tools;if(typeof secret==="string"||this.config.key==="aead"){if(this.config.key==="key")this.computedkey=secret;if(this.config.key==="hash")this.computedkey=this.key("hash",secret,this.config.salt);if(this.config.key==="argon2")this.computedkey=this.key("argon2",secret,this.config.salt);if(this.config.key==="aead")this.computedkey=this.key();this.salt=this.config.salt}if(typeof string==="string")this.encrypt(string,
    secret,box)}encrypt(string,secret,box,isKey){if(typeof secret==="undefined"&&this.computedkey){secret=this.computedkey;isKey=true}if(!string||!secret)throw"SeaSalt_AEAD_XChaCha::encrypt requires a string or secret to encrypt";if(typeof box==="boolean"){isKey=box;box=undefined}if(box instanceof SeaSalt_AEAD_SecretBox&&typeof box.box==="string")box=box.box;else if(box&&typeof box!=="string")throw"SecretBox is invalid";if(typeof box==="string"){let contents=this.decrypt(box,secret);if(typeof contents===
    "string"){let object;try{object=JSON.parse(contents)}catch(e){}secret=typeof object==="object"?object.secret:contents}else throw"Failed to decrypt secret box.";}if(this.tools.passwordStrength(secret)<this.config.minimumStrength)throw"Password does not meet minimum strength requirements";let key=sodium.from_hex(isKey===true?secret:this.key("hash",secret,this.config.salt));let nonce=sodium.randombytes_buf(this.sodium.nonce_bytes);let ciphertext=this.sodium.encrypt(string,"","",nonce,key);sodium.memzero(key);
    this.ciphertext=sodium.to_hex(nonce)+sodium.to_hex(ciphertext);this.box=box;return this.ciphertext}decrypt(string,secret,box,isKey){if(typeof secret==="undefined"&&this.computedkey){secret=this.computedkey;isKey=true}if(!string||!secret)throw"Requires a string and secret to decrypt";if(typeof box==="boolean"){isKey=box;box=undefined}if(box instanceof SeaSalt_AEAD_SecretBox&&typeof box.box==="string")box=box.box;else if(box&&typeof box!=="string")throw"Secretbox is invalid";if(typeof box==="string"){let contents=
    this.decrypt(box,secret);if(typeof contents==="string"){let object;try{object=JSON.parse(contents)}catch(e){}secret=typeof object==="object"?object.secret:contents}else throw"Failed to decrypt secret box.";}let nonce;let ciphertext;try{nonce=sodium.from_hex(string.substr(0,this.sodium.nonce_bytes*2));ciphertext=sodium.from_hex(string.substr(this.sodium.nonce_bytes*2,string.length))}catch(e){return undefined}let key=sodium.from_hex(isKey===true?secret:this.key("hash",secret,this.config.salt));let result=
    "";try{result=this.sodium.decrypt("",ciphertext,"",nonce,key)}catch(e){}sodium.memzero(key);return result?sodium.to_string(result):undefined}key(type,secret,salt){if(type==="hash")return this.hash.sha256(secret,salt);if(type==="argon2"){if(typeof secret!=="string"||secret.length===0)throw"Argon2 secret not provided";return(new SeaSalt_PWHash_Argon2).derive(secret,salt).key}if(type==="scrypt"){if(typeof secret!=="string"||secret.length===0)throw"SCrypt secret not provided";return(new SeaSalt_PWHash_SCrypt).derive(secret,
    salt).key}return sodium.to_hex(this.sodium.keygen())}toJSON(){let data={box:this.box,ciphertext:this.ciphertext};return JSON.stringify(data,null,5)}}
class SeaSalt_AEAD_XChaCha{constructor(string,secret,box,config){if((typeof box==="object"||typeof secret==="object")&&typeof config==="undefined"){if(typeof secret==="object"){config=secret;secret=undefined;box=undefined}if(typeof box==="object"&&(!(box instanceof SeaSalt_AEAD_SecretBox)||!box.box)){config=box;box=undefined}}if(typeof string==="object"){config=string;string=undefined}if(typeof config!=="object")config={};config.cipher="xchacha";return new SeaSalt_AEAD(string,secret,box,config)}}
class SeaSalt_AEAD_ChaCha20_IETF{constructor(string,secret,box,config){if((typeof box==="object"||typeof secret==="object")&&typeof config==="undefined"){if(typeof secret==="object"){config=secret;secret=undefined;box=undefined}if(typeof box==="object"&&(!(box instanceof SeaSalt_AEAD_SecretBox)||!box.box)){config=box;box=undefined}}if(typeof string==="object"){config=string;string=undefined}if(typeof config!=="object")config={};config.cipher="chacha20_ietf";return new SeaSalt_AEAD(string,secret,box,
    config)}}
class SeaSalt_AEAD_ChaCha20{constructor(string,secret,box,config){if((typeof box==="object"||typeof secret==="object")&&typeof config==="undefined"){if(typeof secret==="object"){config=secret;secret=undefined;box=undefined}if(typeof box==="object"&&(!(box instanceof SeaSalt_AEAD_SecretBox)||!box.box)){config=box;box=undefined}}if(typeof string==="object"){config=string;string=undefined}if(typeof config!=="object")config={};config.cipher="chacha20";return new SeaSalt_AEAD(string,secret,box,config)}}
class SeaSalt_Tools{constructor(config){let self=this;this.config={minimumEntropy:6,minimumKeyLength:6,minimumStrength:1};if(typeof config==="object")Object.keys(config).filter(function(key){if(typeof self.config[key]!=="undefined")self.config[key]=config[key]});if(typeof this.config.logger==="undefined")this.config.logger=console.log}randomString(length,alpha,caps,numbers,symbols){let config={length:typeof length==="number"?length:32,alpha:typeof alpha==="boolean"?alpha:true,caps:typeof caps==="boolean"?
        caps:true,numbers:typeof numbers==="boolean"?numbers:true,symbols:typeof symbols==="boolean"?symbols:true};if(typeof length==="object")Object.keys(length).filter(function(key){if(typeof config[key]!=="undefined")config[key]=length[key]});let pools={alpha:"abcdefghijklmnopqrstuvwxyz",caps:"ABCDEFGHIJKLMNOPQRSTUVWXYZ",numbers:"0123456789",symbols:"[];',./<>?:\"{}\\|!@#$%^&*()-=_+`~"};let pool="";if(config.alpha===true)pool=pool.concat(pools.alpha);if(config.caps===true)pool=pool.concat(pools.caps);
    if(config.numbers===true)pool=pool.concat(pools.numbers);if(config.symbols===true)pool=pool.concat(pools.symbols);if(pool.length===0)throw"No character pool has been provided";let string="";for(let i=0;i<config.length;i++)string+=pool.charAt(sodium.randombytes_uniform(pool.length));return string}passwordStrength(password){let strength=0;let cat=0;let matches={};if(matches.alpha=password.match(/[a-z]/g))strength++;if(matches.caps=password.match(/[A-Z]/g))strength++;if(matches.numeric=password.match(/[0-9]/g))strength++;
    if(matches.symbol=password.match(/[-!$%^&*()_+|~=`{}\[\]:#";'@<>?,.\/]/g))strength++;cat=strength;let chars=[];for(let i in matches)if(matches.hasOwnProperty(i))if(typeof matches[i]==="object"&&matches[i]!==null&&matches[i].length)for(let x=0;x<matches[i].length;x++)if(chars.indexOf(matches[i][x].toLowerCase())===-1)chars.push(matches[i][x].toLowerCase());if(chars.length>=this.config.minimumEntropy)strength=strength++;if(chars.length<this.config.minimumEntropy)strength=strength-3;if(strength===1&&
        password.length>=this.config.minimumKeyLength*2)strength++;if(password.length<this.config.minimumKeyLength+4)strength--;if(cat===1)strength--;if(password.length<this.config.minimumKeyLength)strength=0;if(strength<0)strength=0;if(strength>4)strength=4;return strength}}
class SeaSalt_Keychain{constructor(sig,password,config){if(typeof sig==="object"){config=sig;sig=undefined;password=undefined}let self=this;this.test=[];this.config={encCipher:"xchacha",encKey:"aead",debug:false,genericKeyLength:16,hash:"sha256",keysaltLength:24,lockSessionTtl:144E5,maxRecoveryAge:undefined,maxRecoveryPoints:5,minimumEntropy:6,minimumKeyLength:6,minimumStrength:1,mode:0,readonly:false,recoveryTokenCount:2,recoveryTokenLength:12,saltLength:16,signatureLength:16,storage:{checksums:false,
        enabled:true,includeMeta:false,lock:true,lockMode:"write",prefix:"seasalt:keychain:",read:function(key){return localStorage.getItem(key)},write:function(key,value){return localStorage.setItem(key,value)},delete:function(key){return localStorage.removeItem(key)},list:function(){return Object.keys(localStorage)}},log:undefined};if(typeof sig==="string"&&typeof password==="string"){this.config.sig=sig;this.config.password=password;sig=undefined;password=undefined}if(typeof config==="object")Object.keys(config).filter(function(key){if(typeof config[key]!==
    "object")self.config[key]=config[key];if(typeof config[key]==="object")Object.keys(config[key]).filter(function(k2){self.config[key][k2]=config[key][k2]})});if(typeof this.config.storage.prefix!=="string")this.error("No storage prefix has been specified");if(typeof this.config.log!=="function")this.config.log=function(){if(this.config.debug===true){if(typeof arguments[0]==="string")console.log.apply(null,arguments);if(typeof arguments[0]==="object")console.error(null,arguments)}};let regex=new RegExp("^"+
    this.config.storage.prefix+"([a-zA-Z0-9]*?):keyconf$");this.keys={};this.config.storage.list().filter(function(key){let matches=key.match(regex);if(matches===null)return;let data;try{data=JSON.parse(self.config.storage.read(key))}catch(e){return}self.keys[matches[1]]=data});this.aead=this.gen_aead();this.tools=new SeaSalt_Tools(config);this.history={};this.enabled=true;this.active=undefined;this.keysalt="0xk*S#x9";this.runtimeId=(new SeaSalt_Hashing).short(Date.now().toString());this.ready=true;this.log("SeaSalt/Keychain initialized successfully");
    if(this.config.sig&&this.config.password){try{this.open(this.config.sig,this.config.password)}catch(e){delete this.config.sig;delete this.config.password;this.error("SeaSalt/Keychain failed to open key with error: "+e)}delete this.config.sig;delete this.config.password}}gen_aead(config){if(typeof config==="string"){if(typeof this.keys[config]==="undefined")this.error("Invalid key signature provided");config={key:this.keys[config].encKey,salt:this.keys[config].encSalt,cipher:this.keys[config].encCipher}}return new SeaSalt_AEAD(typeof config===
"object"?config:this.keys[this.active]?{key:this.keys[this.active].encKey,salt:this.keys[this.active].encSalt,cipher:this.keys[this.active].encCipher}:undefined)}error(message){throw message;}hash(string,salt,hash){if(typeof hash==="string"&&["sha256","sha512"].indexOf(hash.toLowerCase())===-1)hash=this.config.hash;if(typeof salt!=="string")salt="";return(new SeaSalt_Hashing(salt+string+salt,hash||this.config.hash)).toString()}key(key){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");
    let enckey;if(this.keys[this.active].mode===0)enckey=this.hash(key,this.keysalt,"sha256");if(this.keys[this.active].mode===1)enckey=this.hash(key,this.keysalt,"sha512");if(this.keys[this.active].mode===2)enckey=(new SeaSalt_Hashing).generic(key,this.keysalt,{size:this.keys[this.active].genericKeyLength||this.config.genericKeyLength,force:true});if(typeof enckey!=="string")enckey=this.hash(key,this.keysalt);return this.config.storage.prefix+this.active+":storage:"+this.keys[this.active].format+":"+
        this.keys[this.active].mode+":"+enckey}keyconf(config){let object={box:"",encCipher:this.config.encCipher,encKey:this.config.encKey,encSalt:this.config.encSalt,format:0,genericKeyLength:this.config.genericKeyLength,history:[],mode:this.config.mode,name:"",recovery:{},salt:""};if(typeof config!=="object")config={};Object.keys(config).filter(function(key){if(typeof object[key]==="undefined")return;object[key]=config[key]});if(typeof object.encCipher==="undefined")object.encCipher="xchacha";if(object.mode!==
    2)delete config.genericKeyLength;return object}listkeys(){return Object.keys(this.keys)}lock(state,force){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(force!==true&&this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.config.storage.enabled!==true)this.error("LocalStorage is not enabled");let lockfile;let lockkey=this.config.storage.prefix+this.active+":lock";try{lockfile=JSON.parse(this.config.storage.read(lockkey))}catch(e){}if(force===
    true||lockfile===null||typeof lockfile!=="object"||!lockfile.runtimeId||lockfile.runtimeId===this.runtimeId||Date.now()-lockfile.date>this.config.lockSessionTtl){if(state===true)lockfile={date:Date.now(),runtimeId:this.runtimeId};if(state===false)lockfile={};try{this.config.storage.write(lockkey,JSON.stringify(lockfile))}catch(e){this.log("Encountered storage API error: "+e);return false}if(state===true&&force===true)this.config.readonly=false;return true}this.log("Encountered active lock file: "+
    JSON.stringify(lockfile));return false}log(arg){this.config.log.apply(this,arguments)}save(force){if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===true&&force!==true)this.error("Keychain is in read-only mode");if(this.config.storage.enabled!==true)this.error("LocalStorage is not enabled");if(typeof this.keys[this.active]!=="object"&&force!==true)this.error("Keychain state not ready");try{this.config.storage.write(this.config.storage.prefix+this.active+":keyconf",
    JSON.stringify(this.keys[this.active]))}catch(e){this.log("SeaSalt/Keychain failed to write keyconf to localStorage: "+e);return false}this.log("SeaSalt/Keychain successfully wrote config to localStorage");return true}check(sig,userPassword){return this.open(sig,userPassword,true)}close(){if(this.config.storage.lock===true&&this.config.storage.lockMode==="session")this.lock(false);this.active=undefined;this.passphrase=undefined;this.keysalt=undefined;return true}create(userPassword,config){if(this.ready!==
    true)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.tools.passwordStrength(userPassword)<this.config.minimumStrength)this.error("Password does not meet minimum strength requirements");if(typeof config!=="object")config={};if(typeof config.encKey!=="string")config.encKey="aead";if(typeof config.encCipher!=="string")config.encCipher="xchacha";let mode=config.mode;let name=config.name||(new Date).toLocaleString();let sig=(new SeaSalt_Tools).randomString(this.config.signatureLength,
    true,true,true,false);let salt=(new SeaSalt_Tools).randomString(this.config.saltLength);let keysalt=(new SeaSalt_Tools).randomString(this.config.keysaltLength);let passphrase=this.hash(this.hash(userPassword),salt);this.log("SeaSalt/Keychain - generating encryption key: "+(config.encKey||this.config.encKey)+" "+(config.encCipher||this.config.encCipher));if(["scrypt","argon2"].indexOf(config.encKey)>-1||typeof config==="undefined"&&["scrypt","argon2"].indexOf(this.config.encKey)>-1)this.log("+ "+(config.encKey||
    this.config.encKey)+" may take awhile on slower machines");let secretbox=new SeaSalt_AEAD_SecretBox(passphrase,{key:config.encKey||this.config.encKey,salt:config.encSalt,cipher:config.encCipher||this.config.encCipher,keysalt:keysalt,secret:(new SeaSalt_AEAD({key:config.encKey,salt:config.encSalt,cipher:config.encCipher})).key(config.encKey,userPassword,config.encSalt)});this.keys[sig]=this.keyconf({mode:[0,1,2].indexOf(mode)>-1?mode:this.config.mode,box:secretbox.box,name:name,salt:salt,encKey:config.encKey||
        this.config.encKey,encSalt:config.encSalt||undefined,encCipher:config.encCipher||this.config.encCipher});if(!this.active){this.active=sig;this.passphrase=passphrase;this.keysalt=keysalt}let codes={};for(let i=0;i<this.config.recoveryTokenCount;i++){let data=this.create_recovery(sig,userPassword);this.keys[sig].recovery[this.hash(data.code)]=data.token;codes[data.code]=data.token}if(this.save()===true)return{sig:sig,codes:codes};return false}export_key(sig,raw){if(this.ready!==true||sig!==true&&this.listkeys().indexOf(sig||
    this.active)===-1)this.error("Keychain state not ready");if(raw===true)return sig===true?this.keys:this.keys[sig||this.active];return JSON.stringify(sig===true?this.keys:this.keys[sig||this.active],null,5)}import_key(data,sig,confirm,force){if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(typeof sig==="string"&&confirm!==true)this.error("You must confirm requests that overwrite existing key configurations or use custom signatures");
    if(typeof sig==="string"&&!this.keys[sig]&&force!==true)this.error("Key signature does not exist");if(typeof sig!=="string")sig=(new SeaSalt_Tools).randomString(this.config.signatureLength,true,true,true,false);if(typeof data==="string")try{data=JSON.parse(data)}catch(e){}if(typeof data!=="object")this.error("Invalid key configuration provided");let keyconf;try{keyconf=this.keyconf(data)}catch(e){this.error("Error while processing keyconf: "+e)}if(typeof keyconf!=="object")this.error("Final key configuration was invalid");
    this.keys[sig]=keyconf;return{sig:sig,save:this.save(true)}}modify(sig,config,confirm){if(typeof sig==="object"){confirm=config;config=sig;sig=undefined}if(this.ready!==true||sig!==true&&this.listkeys().indexOf(sig||this.active)===-1)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(typeof config!=="object"||Object.keys(config).length===0)this.error("Invalid user configuration provided");let restricted=["box","salt","mode"];let forbidden=
    ["recovery","history","format"];let self=this;let keyconf=this.keyconf();Object.keys(config).filter(function(key){if(typeof keyconf[key]==="undefined")return;if(restricted.indexOf(key)>-1&&confirm!==true)self.error("You must explicitly confirm calls that use restricted config keys. Offending key: "+key);if(forbidden.indexOf(key)>-1)self.error("You are not allowed to modify key: "+key);if(key==="mode"&&[0,1,2].indexOf(config[key])===-1)self.error("Mode can only be values 0, 1, or 2")});Object.keys(config).filter(function(key){self.keys[sig||
self.active][key]=config[key]});this.log("SeaSalt/Keychain modified key signature "+(sig||this.active)+" keys: "+Object.keys(config).join(", "));return this.save()}open(sig,userPassword,check){if(!userPassword){userPassword=sig;let keys=this.listkeys();sig=keys.length===1?keys[0]:undefined}if(this.ready!==true||typeof this.keys[sig]!=="object")this.error("Keychain state not ready or invalid signature provided");let passphrase=this.hash(this.hash(userPassword),this.keys[sig].salt);let encrypted;let aead=
    this.gen_aead({key:this.keys[sig].encKey,salt:this.keys[sig].encSalt,cipher:this.keys[sig].encCipher});try{encrypted=aead.encrypt("testing",passphrase,this.keys[sig].box);if(aead.decrypt(encrypted,passphrase,this.keys[sig].box)!=="testing")return false}catch(e){return false}if(check===true)return true;this.active=sig;this.passphrase=passphrase;this.keysalt=this.get_keysalt({key:this.keys[sig].encKey,salt:this.keys[sig].encSalt,cipher:this.keys[sig].encCipher});if(this.config.storage.lock===true&&
    this.config.storage.lockMode==="session"&&this.lock(true)===false)this.config.readonly=true;this.log("SeaSalt/Keychain opened key with signature: "+sig);return true}store_history(sig,skipSave){if(this.ready!==true||this.listkeys().indexOf(sig||this.active)===-1)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.keys[sig||this.active].history.indexOf(this.keys[sig||this.active].box)>-1)return true;this.keys[sig||this.active].history.push(this.keys[sig||
this.active].box);return skipSave===true?true:this.save()}update(newPassword){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.tools.passwordStrength(newPassword)<this.config.minimumStrength)this.error("Password does not meet minimum strength requirements");if(typeof newPassword==="string"&&typeof this.keys[this.active]==="object")this.store_history();let passphrase=
    typeof newPassword==="string"?this.hash(this.hash(newPassword),this.keys[this.active].salt):undefined;this.keys[this.active].box=(new SeaSalt_AEAD_SecretBox({key:this.config.encKey,salt:this.config.encSalt,cipher:this.config.encCipher})).repackage(this.keys[this.active].box,this.passphrase,passphrase||this.passphrase);if(passphrase)this.passphrase=passphrase;return this.save()}create_recovery(sig,userPassword,box){if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===
    true)this.error("Keychain is in read-only mode");let hash=false;if(typeof userPassword==="undefined")hash=true;if(hash===true&&sig!==this.active)this.error("Passphrase can only be used with opened keys");if(!box&&(typeof this.keys[sig||this.active]!=="object"||hash===false&&typeof userPassword!=="string"||hash===true&&typeof this.passphrase!=="string"))this.error("Invalid arguments");let passphrase=hash===false?this.hash(this.hash(userPassword),this.keys[sig||this.active].salt):this.passphrase;let code=
    this.tools.randomString(this.config.recoveryTokenLength,false,false,true,false);let token=(new SeaSalt_AEAD_SecretBox({key:this.keys[sig].encKey||this.config.encKey,salt:this.keys[sig].encSalt||this.config.encSalt,cipher:this.keys[sig].encCipher||this.config.encCipher})).repackage(box||this.keys[sig||this.active].box,passphrase,this.hash(this.hash(code),this.keys[sig||this.active].salt));return{code:code,token:token}}find_recovery(sig,code,boxes){if(typeof this.keys[sig]!=="object")this.error("Invalid signature");
    if(typeof boxes==="undefined")boxes=Object.values(this.keys[sig].recovery);if(typeof boxes==="string")boxes=[boxes];if(!Array.isArray(boxes))return[];let self=this;boxes=boxes.filter(function(box){let encrypted;let aead=self.gen_aead(sig);try{encrypted=aead.encrypt("testing",self.hash(self.hash(code),self.keys[sig].salt),box)}catch(e){}if(!encrypted)return false;let decrypted;try{decrypted=aead.decrypt(encrypted,self.hash(self.hash(code),self.keys[sig].salt),box)}catch(e){}return decrypted==="testing"});
    return boxes}restore_recovery(sig,code,boxes,newPassword){if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.listkeys().indexOf(sig)===-1)this.error("Invalid signature");if(typeof newPassword!=="string")this.error("Supplied new password is invalid");if(typeof boxes==="string")boxes=[boxes];if(!Array.isArray(boxes))this.error("Supplied box is not valid");if(this.tools.passwordStrength(newPassword)<this.config.minimumStrength)this.error("Password does not meet minimum strength requirements");
    let self=this;let passphrase=this.hash(this.hash(newPassword),this.keys[sig].salt);let codephrase=this.hash(this.hash(code),this.keys[sig].salt);let secretbox;boxes.filter(function(box){if(typeof secretbox==="string")return;try{secretbox=(new SeaSalt_AEAD_SecretBox({key:self.keys[sig].encKey||self.config.encKey,salt:self.keys[sig].encSalt||self.config.encSalt,cipher:self.keys[sig].encCipher||self.config.encCipher,passphrase:codephrase})).repackage(box,codephrase,passphrase)}catch(e){}});if(typeof secretbox!==
        "string")return false;this.active=sig;this.passphrase=passphrase;this.ready=true;this.store_history(sig,true);this.keys[sig].box=secretbox;this.keysalt=this.get_keysalt();return this.save()}get_keysalt(config){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready or invalid signature provided");let jsdoc=this.gen_aead(config).decrypt(this.keys[this.active].box,config&&config.passphrase||this.passphrase);try{jsdoc=JSON.parse(jsdoc)}catch(e){}if(typeof jsdoc===
    "object"&&jsdoc.keysalt)return jsdoc.keysalt;this.error("Failed to locate keysalt")}decrypt(ciphertext){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");return this.gen_aead().decrypt(ciphertext,this.passphrase,this.keys[this.active].box)}encrypt(string){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");return this.gen_aead().encrypt(string,this.passphrase,this.keys[this.active].box)}read(key,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     meta){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(this.config.storage.enabled!==true){this.log("SeaSalt/Keychain is bypassing a read request because localStorage is turned off");return}if(typeof meta!=="boolean")meta=this.config.storage.includeMeta===true?this.config.storage.includeMeta:false;let ciphertext;try{ciphertext=this.config.storage.read(this.key(key))}catch(e){}if(!ciphertext)return;let json=this.decrypt(ciphertext);let data;try{data=
    JSON.parse(json)}catch(e){}if(typeof data!=="object")data={};return meta===true?data:data.data}read_meta(key,name){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(typeof name!=="string")name="*";let data;let regex=new RegExp("^"+this.config.storage.prefix+this.active+":storage:.*$");if(key.match(regex)===null)key=this.key(key);try{data=JSON.parse(this.decrypt(this.config.storage.read(key)))}catch(e){}if(typeof data==="object"&&data.meta&&(["*",
    "all"].indexOf(name)>-1||data.meta[name]))return["*","all"].indexOf(name)>-1?data.meta:data.meta[name];return false}write(key,value,meta,force){if(typeof meta==="boolean"){force=meta;meta=undefined}if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(this.config.readonly===true&&force!==true)this.error("Keychain is in read-only mode");if(this.config.storage.enabled!==true&&force!==true){this.log("SeaSalt/Keychain is bypassing a write request because localStorage is turned off");
    return false}if(typeof key!=="string"||typeof value!=="string")this.error("Arguments not valid");if(typeof meta!=="object")meta={};if(this.config.storage.lock===true&&this.config.storage.lock==="write")this.lock(true);if(this.config.storage.checksums===true)meta.checksum={sha256:(new SeaSalt_Hashing(value,"sha256")).hex,sha512:(new SeaSalt_Hashing(value,"sha512")).hex};meta.key=key;meta.size=value.length;if(!meta.filetype)meta.filetype="text/plain";meta.date=new Date;let data={meta:meta,data:value};
    let ciphertext=this.encrypt(JSON.stringify(data));if(typeof ciphertext!=="string"){if(this.config.storage.lock===true&&this.config.storage.lock==="write")this.lock(false);return false}key=this.key(key);try{this.config.storage.write(key,ciphertext)}catch(e){if(this.config.storage.lock===true&&this.config.storage.lock==="write")this.lock(false);return false}if(this.config.storage.lock===true&&this.config.storage.lock==="write")this.lock(false);return key}clean(config,scan){if(this.ready!==true)this.error("Keychain state not ready");
    if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.config.storage.enabled===false)this.error("Clean requires that local storage be enabled.");if(config==="all")config=["mode","history","storage"];if(typeof config==="string")config=[config];if(typeof config==="undefined")config=[];if(!Array.isArray(config))this.error("Invalid configuration provided");if(config.length===0)this.error("Your configuration is empty");let self=this;let cleaned={storage:[],mode:[],history:[]};
    if(config.indexOf("storage")>-1||config.indexOf("mode")>-1)this.config.storage.list().filter(function(key){let regex=new RegExp("^"+self.config.storage.prefix+"([a-zA-Z0-9]*):storage:[0-9]*?:([0-9]*?):.*$");let matches=key.match(regex);if(matches===null)return;if(config.indexOf("storage")>-1&&self.listkeys().indexOf(matches[1])===-1){cleaned.storage.push(key);if(scan!==true)self.config.storage.delete(key)}if(config.indexOf("mode")>-1&&self.listkeys().indexOf(matches[1])>-1&&self.keys[matches[1]].mode.toString()!==
        matches[2]){cleaned.mode.push(key);if(scan!==true)self.config.storage.delete(key)}});if(config.indexOf("history")>-1)Object.keys(this.history).filter(function(key){if(self.listkeys().indexOf(key)>-1)return;cleaned.history.push(key);if(scan!==true)delete self.history[key]});return cleaned}destroy(sig,history,purge){if(typeof sig==="boolean"){purge=history;history=sig;sig=undefined}if(this.ready!==true||this.listkeys().indexOf(sig||this.active)===-1)throw"Signature does not exist or keychain is not ready";
    if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(history!==true)this.history[sig||this.active]=this.keys[sig||this.active];delete this.keys[sig||this.active];this.config.storage.delete(this.config.storage.prefix+(sig||this.active)+":keyconf");if(purge===true)this.purge(sig||this.active,false,true);if(sig===undefined||sig===this.active)this.close()}purge(sig,all,confirm,reverse,history){if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===
    true)this.error("Keychain is in read-only mode");if(this.config.storage.enabled!==true){this.log("SeaSalt/Keychain is bypassing a purge request because localStorage is turned off");return}if(this.listkeys().indexOf(sig)===-1&&all!==true)this.error("Signature does not exist");if(typeof all!=="boolean")this.error("Invalid arguments");if(confirm!==true)this.error("You must confirm this action in the third argument");let self=this;let keys=this.config.storage.list().filter(function(key){if(reverse===
    true)return key.indexOf(self.config.storage.prefix)>-1&&key.indexOf("keyring")===-1&&key.indexOf(":"+sig+":")===-1;else return key.indexOf(self.config.storage.prefix)>-1&&key.indexOf(":"+sig+":")>-1});let sigs=[];keys.filter(function(key){self.config.storage.delete(key);let regex=new RegExp("^"+self.config.storage.prefix+"([a-zA-Z0-9]*):([a-z]*):[0-9]*?:[0-9]*?:.*$");let matches=key.match(regex);if(matches!==null&&sigs.indexOf(matches[1])===-1)sigs.push(matches[1])});this.log("SeaSalt/Keychain purged storage keys: "+
    JSON.stringify(keys));if(reverse===true)Object.keys(this.keys).filter(function(csig){if(csig!==sig&&sigs.indexOf(csig)===-1)sigs.push(csig)});if(all===true){this.log("SeaSalt/Keychain purged signatures: "+JSON.stringify(sigs));sigs.filter(function(sig){try{self.destroy(sig,history)}catch(e){}})}if(all===true&&sigs.indexOf(this.active)>-1)this.close();return{storage:keys,sigs:all===true?sigs:[]}}rekey(confirm){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");
    if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.config.storage.enabled!==true){this.log("SeaSalt/Keychain is bypassing a rekey request because localStorage is turned off");return}if(confirm!==true)this.error("Confirmation argument not provided");let self=this;let oldbox=this.keys[this.active].box;if(this.store_history()===false)this.error("Failed to save history key");let contents=this.gen_aead().decrypt(oldbox,this.passphrase);if(typeof contents!=="string")this.error("Box contents are invalid");
    let object;try{object=JSON.parse(contents)}catch(e){}if(typeof object==="object"&&!object.secret)throw"Invalid box contents detected";this.log("SeaSalt/Keychain - generating encryption key: "+this.keys[this.active].encKey+" "+this.keys[this.active].encCipher);if(["scrypt","argon2"].indexOf(this.keys[this.active].encKey)>-1)this.log("+ "+this.keys[this.active].encKey+" may take awhile on slower machines");contents=(new SeaSalt_AEAD({cipher:this.keys[this.active].encCipher})).key(this.keys[this.active].encKey,
        this.tools.randomString(),this.keys[this.active].encSalt);if(typeof object==="object"){object.secret=contents;contents=JSON.stringify(object)}let newbox=(new SeaSalt_AEAD_SecretBox(this.passphrase,contents,{key:this.config.encKey,salt:this.config.encSalt,cipher:this.config.encCipher})).box;let error=[];let modified=this.config.storage.list().filter(function(key){let regex=new RegExp("("+self.active+":storage:)");if(key.match(regex)!==null){let contents=self.config.storage.read(key);let decrypted;
        try{decrypted=self.gen_aead().decrypt(contents,self.passphrase,oldbox)}catch(e){error.push(key);return}self.config.storage.write(key,self.gen_aead().encrypt(decrypted,self.passphrase,newbox));return true}});let codes={};for(let i=0;i<this.config.recoveryTokenCount;i++){let data=this.create_recovery(this.active);this.keys[this.active].recovery[this.hash(data.code)]=data.token;codes[data.code]=data.token}this.keys[this.active].box=newbox;if(this.save()===false)return{success:false,error:error,modified:modified,
        warning:"Failed to save keychain! The attached secret box is necessary for decrypting changed files.",secretbox:this.keys[this.active].box};return{success:true,sig:this.active,codes:codes,modified:modified,error:error}}scan(userPassword,newPassword){if(this.ready!==true)this.error("Keychain state not ready");if(newPassword&&this.config.readonly===true)this.error("Keychain is in read-only mode");if(newPassword&&typeof newPassword!=="string")this.error("Password is not valid");if(newPassword&&this.tools.passwordStrength(newPassword)<
    this.config.minimumStrength)this.error("Password does not meet minimum strength requirements");let self=this;let sigs={};this.listkeys().filter(function(sig){if(self.open(sig,userPassword,true)===true){if(typeof sigs[sig]==="undefined")sigs[sig]={};sigs[sig].keychain=true;sigs[sig].name=self.keys[sig].name;sigs[sig].encCipher=self.keys[sig].encCipher;sigs[sig].encKey=self.keys[sig].encKey;return}if(self.find_recovery(sig,userPassword).length>0){if(typeof sigs[sig]==="undefined")sigs[sig]={};sigs[sig].recovery=
    true}});if(Object.keys(sigs).length<1)return false;if(Object.keys(sigs).length>1)return sigs;let sig=Object.keys(sigs)[0];if(sigs[sig].keychain===true){this.open(sig,userPassword);return sig}if(sigs[sig].recovery===true&&typeof newPassword==="string"&&newPassword.length>0)return this.restore_recovery(sig,userPassword,self.find_recovery(sig,userPassword),newPassword);return sigs}backup(sigs,config){let callback;if(typeof config==="object"&&typeof config.callback==="function")callback=config.callback;
    if(typeof config==="function")callback=config;if(typeof sigs==="function"){callback=sigs;sigs=undefined}if(typeof sigs==="object"&&!Array.isArray(sigs)){config=sigs;sigs=undefined}if(typeof config!=="object")config={};if(typeof callback==="function")config.callback=callback;if(this.ready!==true)this.error("Keychain state not ready");if(typeof config!=="object")config={};if(typeof config.sigs==="string"||Array.isArray(config.sigs))sigs=config.sigs;if(!Array.isArray(config.sigs)&&typeof config.sigs===
        "object")sigs=Object.keys(config.sigs);if(typeof sigs==="string")sigs=[sigs];if(typeof sigs==="undefined")sigs=this.listkeys();if(!Array.isArray(sigs))this.error("Invalid signatures provided");if(typeof JSZip!=="function")this.error("JSZip is required for making backups");let self=this;let zip=new JSZip;if(config.all===true)this.listkeys().filter(function(sig){if(sigs.indexOf(sig)===-1)sigs.push(sig)});sigs.filter(function(sig){let close=false;if(!Array.isArray(config.sigs)&&typeof config.sigs===
        "object"&&config.sigs[sig])try{self.open(sig,config.sigs[sig])}catch(e){}zip.file("keys/"+sig+"/keyconf.json",JSON.stringify(self.keys[sig],null,5));self.config.storage.list().filter(function(key){let regex=new RegExp("^"+self.config.storage.prefix+sig+":([a-zA-Z0-9]*)(?::[0-9]*?:[0-9]*?:(.*))?$");let matches=key.match(regex);if(matches===null)return;let path;if(matches[1]==="storage"&&!Array.isArray(config.sigs)&&typeof config.sigs==="object"&&config.sigs[sig]&&self.active===sig){let data=self.decrypt(self.config.storage.read(key));
        try{data=JSON.parse(data)}catch(e){}if(typeof data==="object"&&data.data&&data.meta){zip.file("keys/"+sig+"/"+matches[1]+"/"+data.meta.key.replace(/^(\/)/,"")+".json",JSON.stringify(data,null,5));return}}if(matches[1]!=="keyconf")zip.file("keys/"+sig+"/"+matches[1]+"/"+(matches[2]||key)+".enc",self.config.storage.read(key))});if(self.active===sig)self.close()});zip.file("meta.json",JSON.stringify({timestamp:Date.now(),date:(new Date).toLocaleString(),sigs:sigs},null,5));if(typeof config.callback!==
        "function")return zip;zip.generateAsync({type:"blob"}).then(function(content){config.callback(content)});return true}restore(file){if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");return false}};
